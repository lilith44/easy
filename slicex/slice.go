package slicex

import "slices"

// ToSliceAny transfers the slice to []any.
func ToSliceAny[S interface{ ~[]E }, E any](s S) []any {
	if s == nil {
		return nil
	}

	slice := make([]any, 0, len(s))
	for i := range s {
		slice = append(slice, s[i])
	}
	return slice
}

// ToMap transfers the slice to a map[K]struct{}.
func ToMap[S interface{ ~[]K }, K comparable](s S) map[K]struct{} {
	if s == nil {
		return nil
	}

	m := make(map[K]struct{}, len(s))
	for i := range s {
		m[s[i]] = struct{}{}
	}
	return m
}

// ToMapFunc transfers the slice to a map whose key(s) is generated by func k.
func ToMapFunc[S interface{ ~[]E }, E any, K comparable](s S, k func(E) K) map[K]E {
	if s == nil {
		return nil
	}

	m := make(map[K]E, len(s))
	for i := range s {
		m[k(s[i])] = s[i]
	}
	return m
}

// ToSliceFunc transfers the slice to a new slice whose element(s) is generated by v.
func ToSliceFunc[S interface{ ~[]E }, E any, K any](s S, v func(E) K) []K {
	if s == nil {
		return nil
	}

	slice := make([]K, 0, len(s))
	for i := range s {
		slice = append(slice, v(s[i]))
	}
	return slice
}

// Deduplicate generates a new slice without duplicated elements.
func Deduplicate[S interface{ ~[]K }, K comparable](s S) []K {
	if s == nil {
		return nil
	}

	slice := make([]K, 0, len(s))
	m := make(map[K]struct{})
	for i := range s {
		if _, ok := m[s[i]]; ok {
			continue
		}

		slice = append(slice, s[i])
		m[s[i]] = struct{}{}
	}
	return slice
}

// DeduplicateFunc generates a new slice without duplicated k generated by dup.
func DeduplicateFunc[S interface{ ~[]E }, E any, K comparable](s S, dup func(E) K) []E {
	if s == nil {
		return nil
	}

	slice := make([]E, 0, len(s))
	m := make(map[K]struct{})
	for i := range s {
		if _, ok := m[dup(s[i])]; ok {
			continue
		}

		slice = append(slice, s[i])
		m[dup(s[i])] = struct{}{}
	}
	return slice
}

// Concat concats all slices into a new slice.
func Concat[S interface{ ~[]E }, E any](s ...S) []E {
	if s == nil {
		return nil
	}

	var slice []E
	for i := range s {
		slices.Grow(slice, len(s[i]))
		slice = append(slice, s[i]...)
	}
	return slice
}

// IsUnique reports whether s does not contain duplicated values.
func IsUnique[S interface{ ~[]K }, K comparable](s S) bool {
	if len(s) <= 1 {
		return true
	}

	m := make(map[K]struct{})
	for i := range s {
		if _, ok := m[s[i]]; ok {
			return false
		}

		m[s[i]] = struct{}{}
	}
	return true
}

// IsUniqueFunc reports whether s does not contain duplicated values generated by del.
func IsUniqueFunc[S interface{ ~[]E }, E any, K comparable](s S, unique func(E) K) bool {
	if len(s) <= 1 {
		return true
	}

	m := make(map[K]struct{})
	for i := range s {
		k := unique(s[i])
		if _, ok := m[k]; ok {
			return false
		}

		m[k] = struct{}{}
	}
	return true
}

// DeleteFunc deletes from s if del is true.
func DeleteFunc[S interface{ ~[]E }, E any](s S, del func(E) bool) []E {
	if s == nil {
		return nil
	}

	slice := make([]E, 0, len(s))
	for i := range s {
		if del(s[i]) {
			continue
		}
		slice = append(slice, s[i])
	}
	return slice
}

// Paging returns a slice of s[(page-1)*size: page*size]. It panics if the page is not positive or the size is negative.
// Notice that this func will never return a nil slice.
func Paging[S interface{ ~[]E }, E any](s S, page, size int64) []E {
	if page <= 0 {
		panic("slicex.Paging: non-positive page")
	}
	if size < 0 {
		panic("slicex.Paging: negative size")
	}

	start, end := (page-1)*size, page*size
	length := int64(len(s))
	if start >= length {
		return []E{}
	}

	if end >= length {
		return s[start:]
	}

	return s[start:end]
}
